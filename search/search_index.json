{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the FilmNeverDie CP800 wiki Sample photos: C41 on ECN2","title":"Home"},{"location":"#welcome-to-the-filmneverdie-cp800-wiki","text":"","title":"Welcome to the FilmNeverDie CP800 wiki"},{"location":"#sample-photos-c41-on-ecn2","text":"","title":"Sample photos: C41 on ECN2"},{"location":"about_variations/","text":"Variations Note: this section is currently empty, but will contain variation-specific documentation.","title":"Variations"},{"location":"about_variations/#variations","text":"Note: this section is currently empty, but will contain variation-specific documentation.","title":"Variations"},{"location":"software/","text":"Software NOTE: this section needs a major overhaul, to make it more developer friendly The user manual has information regarding how to operate the machine. This document is for developers by explaining how the code functions and is structured. There are a lot of iterations of firmware that are applicable to the microcontroller in CP800. Much of the code is shared between all iteration of the firmware. This document will break the firmware by its function and explain each part of it. There is a log of changes written inside the beginning of the main code so developers track when a feature/function was implemented. Of course, that is not the most comprehensive log, so there might be changes that happened between the recorded date. For the sake of documentation, we assume all data recorded on the log is the date of a committed version of the firmware and all changes to between the commits happen on the latest commit. Main Headers #define model \"CP-806\" #define version \"1.16.2\" #define PCBver 9 // sense =0 for NO sensor, and =1 for NC sensor #define OUTsense 0// change this to 1 when use the new flow sensor with the metal band and cable tie #define INsense 0 At the beginning of the code there is a section before the log. This section contains #define for the machine. \u201cmodel\u201d and \u201cversion\u201d are not used functionally as of 8th June 2022. However, PCBver is used to define the pinout for the Dpad and user interface inputs. Since there are two functional PCB being used by CP800 as of 8th June 2022. OUTsense and INsense, is used to defined whether the tank level sensor and flow out sensor are normally open (NO), or normally closed (NC) signal. In the future, more metadata could be defined here so other supporting software could identify the machine and hardware associated with that specific model and version of machine. //#define DEBUG //enable/disable serial debug output #ifdef DEBUG #define DEBUG_PRINT(x) Serial.print(x) #define DEBUG_PRINTDEC(x) Serial.print(x, DEC) #define DEBUG_PRINTbin(x,y) Serial.print(x, y) #define DEBUG_PRINTbinln(x,y) Serial.println(x, y) #define DEBUG_PRINTln(x) Serial.println(x) #else #define DEBUG_PRINT(x) #define DEBUG_PRINTDEC(x) #define DEBUG_PRINTbin(x,y) #define DEBUG_PRINTbinln(x,y) #define DEBUG_PRINTln(x) #endif #define DEBUG serial print via Arduino COM. This allows a global disable on all serial print functions when we don\u2019t want to be debugging. Note that there are still some serial.print functions not controlled by this declaration. void EditsParameters(int editIndex,int arrayIndex,int * Para,int push); There is one function declaration before the main. This function is used to edit existing processing in the ROM. This function required the following dependencies: The data type of ROMProgram struct And Arduino basic library. :information_source: NOTE: it is planned to modularize the ROM processing code to have a separate file and header. The section below the comment: // button assignment is for the position of each button on the Dpad to the R-2R DAC. Then the libraries are included below the line: // includes library Four libraries are active as of 8th June 2022 #include \"classes.h\" #include \"CP800.h\" #include <OneWire.h> #include <DallasTemperature.h> CP800.h and classes.h are defined within the Arduino script folder. LiquidCrystal , OneWire.h + DallasTemperature.h could be installed and updated with libraries manager on Arduino IDE. Following the comment: //pin assignment Are the pin assignments for most GPIO for joystick shield, SPI com, motor interface, valves interface, buzzer, fluid sensors. For the button variables: byte UIcommend; // debounced byte commend to the system from UI inputs byte UIinputs; // before debounced int de_button;// debounced signal from the Dpad buttons int editing = 0; // default program editing is off int menu_skipupdate=0; UIcommned , is the debounced 8 bits signal for the microcontroller, this includes the buttons digital inputs with the 6 MSBs. The 2nd LSB indicated whether the cursor can travel through the columns, whereas the LSB indicated whether the cursor can travel through the rows. UIinputs are the raw signal from the 6 inputs from Dpad de_button is the debounced signal for UIinputs Editing is a flag to indicate whether the user is in editing mode or not, see \u201cediting processing\u201d in the user manual. menu_skipupdate is a flag to control whether the menu is being updated or skipped. Might use a better name These variables are mainly interfacing with the UIcursor and UImap classes which contain the information where the cursor is on the menu, and where in the mapping of the menu. The final inputs are input to the buttonAction subroutine, where the microcontroller reacts to the new inputs every program cycle. //LCD #include <LiquidCrystal.h> #define rs 42 #define ee 43 #define d4 44 #define d5 45 #define d6 46 #define d7 47 //LCD Pin #define bl 36 LiquidCrystal lcd(rs, ee, d4, d5, d6, d7); For the LCD, a new library is included, LiquidCrystal.h , and a set of pin assignment is #define correspondingly to the object imitation of the LCD, see LiquidCrystal object constructor for how to initiate a LCD object with the library. char lcdBuff0[21]; char lcdBuff1[21]; char lcdBuff2[21]; char lcdBuff3[21]; char lcdBuffPrevious0[21]; char lcdBuffPrevious1[21]; char lcdBuffPrevious2[21]; char lcdBuffPrevious3[21]; The LCD screen used has 4 rows of 20 characters. Four lcdbuffer are made to store each position of the LCD. Four more are made to store the previous screen which are currently not used. //menu //menu structure see attached document int menuRow = 0; int menuColumn = 0; int infopage = 0; //there will be multiple info page as we expand the complexity const String menuTop[] = { //top tier menu text ...} const String menuSetting[] = { //declear settings menu ...} menuRow is the row number that the cursor/mapping is currently in menuColumn is the column number that the cursor/mapping is currently in Infopage is the page number that the user is currently viewing menuTop is a character array with words that are shown on the top menu menuSetting is a character array with words that are shown on the setting menu //edit menu int editIndex = 0; int editPara[19]; // edipara is a array, mostly will be only using the first entry int arrayIndex = 0; bool editmenuEnd=0; Three variables are declared under editing menu. These variables are used when the user is in editing ROM program mode. editIndex is the index that indicates the current variable the user is editing. Please see EditsParameters function to see how the entire processing program is flattened and how each data is indexed editPara is the value which the index is referring to. There are several types of datatypes, depending on the indexing the data in the array interpreted as different data type, please refer to EditsParameters function for future information arrayIndex is the index for the character array, processName[]. editmenuEnd is a flag for rather the edit menu reached the end or not //I/O Check bool outputCheckAction = 0; //Input/Output Check Mode bool IOCheckMode = 0; int IOIndex = 0; Three variables are declared to be used when the user is in the IO check mode in the setting menu, see user manual for how to navigate to the IOcheck menu outputCheckAction toggles the action state of each active element of the machine from the menu, typically the component is switched on when this value is 1, such as motor, pump, valve ...etc IOCheckMode indicates if the program is in the IO check menu. This enables the IOIndex to be changed, because the program has entered IO check mode IOIndex is the index that shows which input or output the user is currently checking. Refer to inputCheck() and outputCheck() to see how all inputs and outputs are arranged into an array. //declear process matrix String processPara[8][20] = { //6 process + 2 clean process {}, {}, {}, {}, {}, {}, {}, {} }; int processTemp[8] = {0, 0, 0, 0, 0, 0, 0, 0}; uint16_t processTime[8] = {0, 0, 0, 0, 0, 0, 0, 0}; uint8_t processTotalSteps[8] = {0, 0, 0, 0, 0, 0, 0, 0}; bool processParaSet[8] = {0, 0, 0, 0, 0, 0, 0, 0}; //process name String processName[6] = {\"---\", \"---\", \"---\", \"---\", \"---\", \"---\"}; processPara is an array of 8 with 20 strings each. String is used here because it is made using the old data format where all parameters are compiled into a String datatype processTemp is the temperature value for each process processTime is the duration of each process processTotalSteps is the number of steps in each process processParaSet is the flag that say whether the process has be set (loaded from storage) processName is the name of the process //processing data //timer unsigned long timer = 0; //system timer (mS) long timeJump = 0; //jump forward time for testing (mS) #define iniDelay 200 //delay in setup (mS) Then we will introduce all the data use in processing For timers: Long timer is a system timer where it will update every loop timeJump is an accumulated varaibles that will increase or decrease the timer values (currently unused) iniDelay is the delay amount in ms introduce in the for several component when machine is booting up. These include loading processes from ROM, initiating LED, initiating motor. //refresh timer for lcd etc. unsigned long refreshTimerA = 0; //timer for less frequent refresh (ms) unsigned long refreshTimerB = 0; //timer for frequent refresh (ms) #define refreshInterval 500 //time for lcd refresh (ms) refreshTimerA regulate what get update, currently it is at 4 times of refreshInterval which is 2s. These processes are LED, LCD, read temperature refreshTimerB regulates what get updated, currently it is at refresh interval rate which is 0.5s. These processes are controlling the motor, controlling the processing, or the cleaning process. //agitation byte agitationSpeed = 0; //0: ~20RMP 1: ~18RMP 2: ~16RPM unsigned long agitationTimer = 0; // S const int agitationTime1 = 10; // S const int agitationTime2 = 2; // S agitationSpeed determines the speed setting of the motor, this could be expanded to the values of a byte agitationTimer is not used agitationTime1 and agitationTime2 are used to create the pattern of motion during processing. The pattern is forward, stop, backward and stop, then repeat. //parameter of process bool processState; //process runing state (0:not running 1:running) int processNo; //runing process (0-7) bool steppingmode=0; //default =0 : sensor mode, 1= fixed timer unsigned long processStartTime = 0; //start time of current process processState is the flag showing whether the machine is running a processing or not processNo shows which process from the menu is selected to be processing steppingmode shows how the steps in a process are going to progress. Sensor mode means the step progress to the next step depending on the feedback sensor, fixed timer means the step progress to the next only depending on a fixed amount of time. processStartTime marks the timer instance where a new processing has begun. //parameter of clean process byte processStateClean; //process runing state for clean process (0: not runing 1: clean 1 process 2: clean 2 process) byte processCleanCycles; There are supposed to be two cleaning processes, they are both currently not programmed. From the order of adding and removing fluid. Clean 1 is having the both add and remove are active depending on a processing array. //parameters for current step bool stepState = 0; //step state (0: processing of this step is not done 1: processing of this step is done, ready to drain tank) String stepName[20] = {\"----\"}; uint8_t stepNo = 0; uint8_t stepIn[20]; //which port to add chem uint16_t stepTime[20]; //time for processing (S) uint8_t stepOut[20]; //which port to dump chem bool stepPush[20]; //if this step is subject to push/pull 0:no 1:yes bool flowin=0; bool flowout=0; int stepout = 0; // use to record what stepOut[stepNo] is, unused unsigned int stepTimer1 = 0; // begining of adding chem unsigned int stepTimer2 = 0; // beigning of process the drum, stopped adding chem unsigned int stepTimer3 = 0; // begining of removing chem, stpped the drum bool stepParaSet=0; //flag of step paratmeter are set, and ready to go //push/pull int push = 0; // the value of push/pull selected on the menu (this is loaded into the processing later) Within the processing, each step has timing and parameters that define their actions. stepState shows whether the processing of the film in this step is done, if done start draining tank fluid and prepare for the next step stepNo shows sequential order the step is in the processing StepName shows the name for a step stepIn and stepOut shows which valve port which are used in the step stepTime is the duration of the step stepPush enable/disable the step to be pushed/pulled. Push: increase time of processing of this step, pull: reduce time of processing of this step flowin is a flag made to force the chemical to flow in by the user at any time during the step which the processing is currently in flowout is a flag to force the chemical to flow out of port 6 during the process, this is used for emergency flow out in case the other valves are somehow blocked during the processing. Please refer to the user manual. Stepout is supposed to record the value of stepOut the processing was, so that an interrupted operation could be done and yet the processing could continue by pushing this variable back into stepOut (currently unused) stepTimer1 is use to time the adding chemical stage of the step stepTimer2 is use to time the rolling processing stage of the step stepTimer3 is use to time the removing chemical stage of the step stepParaSet shows whether the step parameters are loaded and ready to go push is the value of how much time are increase/decrease (push or pull) for all the pushable steps in the current processing //error Message String errorMessage = \"\"; unsigned long int popuptimer=0; errorMessage is a String for displaying the message when an error incurred popuptimer is a time variable for displaying a message on LCD, this is updated to the newest time, so the popup message will display for a duration of time after this variable is updated #include <EEPROM.h> int strByteLen = 200; //String Length limit in bytes int addrShift = 0; //to shift byte for wear leveling EEPROM is one of the options to store and recall processing, all parameters are stored as a byte array. strByteLen is currently defined as 200 bytes. Detailed structure of the stored array is in the comment section of the CP800.h tab. addrShift is supposed to be a random 8 bits value that shifts the ROM address, in order to achieve wear leveling. The array will have a wrapping order from 256 back to 0. However, the wrapping is not yet programmed. Currently not use. #include <SD.h> #include <SPI.h> #include <stdlib.h> int SD_err =0; // 0: no err, 1: SD.begin error, 2: file load err, 3: step data load err int program_no = 0; // count the number of program stored in the SD card file int loadtype=0; // 1 is SD, and 0 is ROM, default from ROM int validROMprogram[6] = {1,1,1,1,1,1}; //0: invalid, 1:valid Load all libraries required to use SD module on Arduino SD_err is the value that returns from attempt to initiate the SD module program_no is the number of processing program stored on the SD card; the program indicator is located at the beginning of each processing program. More details for the data structured store on SD card are described in \u201cprocess_data\u201d tab loadtype determines how processing program is loaded, either from SD card or EEPROM validROMprogram is an array of flags to indicate which programs stored in the EEMPROM have a valid data structure. If there is no legit program header found in each memory slot, the function will change this array of the corresponding index to 0, so loading on those program entries will be skipped. //digital Temperature Sensor #define tempPin 27 //DS18B20 signal bus OneWire oneWire(tempPin); //Temperature chip i/o DallasTemperature sensors(&oneWire); //Temperature Control float tempCurrent = -10.0; float tempTarget = 22.0; Currently temperature is not use in anyway. This is merely a template for future expansion for now. define pin 27 to be the onewire bus Instantiation of the onewire object to be the define above Instantiation of the dallas temperature sensor to be the one wire bus device tempCurrent and tempTarget are the current and target temperature of the sensor. tempCurrent actually doesn\u2019t need initialization. //instanstation of object Led Led(LED_woke); Buzzer buzz(buzz_pin,volume_pin); SixWay_valve addChem(add_s0,add_s1,add_s2,add_pump); SixWay_valve removeChem(remove_s0,remove_s1,remove_s2,remove_pump); agitationMotor agitationMotor(motor_on, motor_dir, motor_PWM); bathPump bathPump(soak_pump); //tankLevel tankLevel; //soakLevel soakLevel; digilevel drumHI(drum_high,LEVEL_SAMPLE_SIZE, INsense ); digilevel drumempty(drum_empty,LEVEL_SAMPLE_SIZE, OUTsense); //analoglevel chemtanks_full(); //analoglevel chemtanks_half(); //analoglevel chemtanks_low(); analoglevel soakLevel(tanks_full,LEVEL_SAMPLE_SIZE); AC_heater heater(heat_PWM); joystick joystick(KEYA,KEYB,KEYC,KEYD, KEYK, JOYX, JOYY); Dpad_analog panel_UI(Dpad_in_pin, Dpad_refH_pin, Dpad_refL_pin); UIcursor user_navi(&UIcommend); UImap menu_navi(&UIcommend); Now we instantiate all objects needed to operate the machine with the variable we declared previously: LED Buzzer 6ways valve for both inlet and outlet Motor Bathpump, currently no corresponding hardware Digital level sensor for inside the tank and along the outlet tube Analog level sensors are not used The heating element using AC power Joystick shield Dpad interface as the UI The cursor location on the screen is the user The location displayed on the screen is the menu CP800.h This header tab is made to contains classes and global variable for those classes in the CP800 series #include \"pitches.h\" #define arrayLength(array) (sizeof((array))/sizeof((array)[0])) #include <LiquidCrystal.h> #include <EEPROM.h> Libraries used in the classes : pitches.h , EEPROM.h , LiquidCrystal.h pitches.h : has the buzzer value to make different notes and function to generate pre-defined tune LiquidCrystal is the library for display on the LCD EEPROM is the library for accessing the EEPROM on Arduino arrayLength is to calculate the size of an array using sizeof() bool zero_crossed=0; int maxcol=3; //maximum number of col to be display (shift colume by left and right) int rowstack[8][2];//a matrix that stored the row value for both the user cursor and the menu map int colstack[8][2]; //a matrix that stored the col value for both the user cursor and the menu map int actionstack; // the variable to restore which action the menu is selected String lcdStr[4] = {\"\", \"\", \"\", \"\"}; int ispageEnd = 0; //flag indicaitng the end of the menu page int pagerow = 4; //default is four zero_crossed is the flag to indicate whether the AC input of the heating has crossed zero. This allows a fixed energy cycle for the PWM cycle within a certain time error maxcol is the variable that allows users to shift left and right in the menu to see different information rowstack is the data matrix that stored the row coordinate of both the user cursor and menu map colstack is the data matrix that stored the column coordinate of both the user cursor and menu map actionstack is the value for the action that the machine is taking, this is normally on the last page in the menu, where the user has to pick a function or run a program. The previously two stacks are for the location of the menu through each layer of the selection on the menu. lcdStr is the array of 4 strings to be displayed on the LCD ispageEnd is the flag for indicating the menu had reached an end page, a page where you have to select an action and no more option to be select after that pagerow is the number of rows on the current menu page. Usually 4 rows, given the screen has 4 rows, but main menu and program selection has more, and allow scrolling down //this is the view in which the LCD is looking at struct camera{ int col; int row; int row_size; int col_size; }; The camera struct contain the coordinate of the camera and the size in each dimension to be seen by the camera. Imagine it to be the view range of a person on the map. Class UIcursor class UIcursor { private: byte* _inputsRef; byte _inputs; byte _Previnputs; int _rowlimit=3; Private variables include: _inputsRef is the pointer to the input variable _inputs is the variable that take the new inputs _previnputs is the variable that stored the previous inputs _rowlimit is restricted to row 3 (4th row) , because cursor cannot move out of the screen void limit(int *row, int *col){ if (*row>_rowlimit) *row=_rowlimit; if (*row<0) *row=0; if (*col<0) *col=0; } The private function limit() restricts the value of row and column between 0 to the upperlimit , so far only row has an upper limit for the cursor public: int row=0; int col=0; int layer=0; row , col , layer fully describe the location of the cursor on the map //pass the input pointer to the private variable UIcursor (byte* inputs){ _inputsRef = inputs; } Instantiate the class by passing a pointer of a byte void begin(){ //initiate inputs _inputs = *_inputsRef; //when begin, load the value of the input pointer to _inputs _Previnputs = _inputs; // initailise the previous as current inputs Initialize the class by taking the input from the pointer and make previous input the same // can overwrite the current location of the cursor to any positon on the map void wrappoint (int wraprow, int wrapcol, int wraplayer){ row=wraprow; col=wrapcol; layer=wraplayer; } Public function to edit the current location of the cursor to any value // update cursor from the inputs given the number of row to be displayed and wehter it is a end page void Update(int isEnd, int displayrow){ _inputs = *_inputsRef; _rowlimit = displayrow-1; // shift between menu layr with A and B // ULRDAB bool A = (_Previnputs>>A_shift & 1) & ~(_inputs>>A_shift & 1); bool B = (_Previnputs>>B_shift & 1) & ~(_inputs>>B_shift & 1); if (A){ rowstack[layer][2] =row; colstack[layer][2] =col; //stop incrementing if page is an end page if (isEnd!=1){ rowstack[layer][2] =row; layer +=1; // new coordinate for new layer }else{ actionstack = row; // which row is pressed on the action page/end page } // return row and col anyway after pressing A, too hard to see respawn without changes, updated 202011130 row = 0; col = 0; if(layer>3)layer=3; }else if (B){ //use 0 to destroy the layer for returning operation rowstack[layer][2] = 0; colstack[layer][2] = 0; layer -=1; if(layer<0)layer=0; row = rowstack[layer][2]; col = colstack[layer][2]; //clear after unloading into the cursor positoin rowstack[layer][2] = 0; colstack[layer][2] = 0; }else{ The update function is the core function of the class. It updates the position of the cursor by reading and interpreting the buttons inputs, when the update is called. The button shift defined in header will now be used to isolate the A and B button, these buttons confirm or cancel an action. When press A: Stored the current row and column position to the stack If this is the end page, row value is the action option, if not, we increment the layer Then reset row and column position to 0 as we are either doing a new action, Since no page is beyond layer 3, restrict layer increment when reached end, this could be redundant if mapping and tracking is done better When press B: Reset current position to zero in stack Decrement layer Load previous layer position Clear the previous location from stack }else{ /* * row increment when the down button signal transit from 1 to 0 * row decrement when the up button signal transite from 1 to 0 * * commend switch to col if the menu allow colum * * non blocking operation for all direction (could be using in game mode) * ULRDAB */ row += (_Previnputs>>Down_shift & 1) & ~(_inputs>>Down_shift & 1) & _inputs& 1; row -= (_Previnputs>>Up_shift & 1) & ~(_inputs>>Up_shift & 1) & _inputs& 1; // we may not need col position for the cursor col += (_Previnputs>>Right_shift & 1) & ~(_inputs>>Right_shift & 1) & (_inputs>>1 & 1); col -= (_Previnputs>>Left_shift & 1) & ~(_inputs>>Left_shift & 1) & (_inputs>>1 & 1); limit(&row,&col); } // restore previous inputs _Previnputs = _inputs; } }; When press other buttons Increment or decrement row value if press up and down while row shift bit is enabled ( _inputs&1 ) Increment or decrement column value if press left and right while row shift bit is enabled ( _inputs>>1&1 ) Check and limit row and column according to the boundary of the menu page Always, update input to previous input at the end Class UImap This class is very similar to UIcursor , in fact, it could be position to generalise both UImap and UIcursor class into one class. class UImap{ private: //map has a camera datatype to contain the dispaly size and location of the menu camera _mapCam; byte* _inputsRef; byte _inputs; byte _Previnputs; int _rowlimit=3; //default typical 4 row, 0-3 void limit(int *row, int *col){ if (*row>_rowlimit) *row=_rowlimit; if (*row<0) *row=0; if (*col<0) *col=0; All except the inclusion of camera struct is the same as UIcursor . Camera structs allow UImap not only the position but the range of location that is visible void begin(){ _mapCam.row=0; //start at the top _mapCam.col=0; //start at the left _mapCam.row_size = 4; //default dispalying 4 row of character _mapCam.col_size = 19;//default dispalying 19 character //initiate inputs _inputs = *_inputsRef; _Previnputs = _inputs; } Initialize class with camera values, and camera sizes are fixed void wrappoint (int wraprow, int wrapcol, int wraplayer) Exact same function as UIcursor void Update(int isEnd, int displayrow){ _inputs = *_inputsRef; _rowlimit = displayrow-1; // shift between menu layr with A and B bool A = (_Previnputs>>A_shift & 1) & ~(_inputs>>A_shift & 1); bool B = (_Previnputs>>B_shift & 1) & ~(_inputs>>B_shift & 1); if (A){ colstack[layer][1] =col; if (isEnd!=1){ rowstack[layer][1] =row; layer +=1; // new coordinate for new layer row = 0; col = 0; }else{ actionstack = row; } if(layer>3)layer=3; Update mirror the UIcursor }else{ /* row += (_Previnputs>>Down_shift & 1) & ~(_inputs>>Down_shift & 1) & _inputs& 1; row -= (_Previnputs>>Up_shift & 1) & ~(_inputs>>Up_shift & 1) & _inputs& 1; // we may not need col position for the cursor col += (_Previnputs>>Right_shift & 1) & ~(_inputs>>Right_shift & 1) & (_inputs>>1 & 1); col -= (_Previnputs>>Left_shift & 1) & ~(_inputs>>Left_shift & 1) & (_inputs>>1 & 1); limit(&row,&col); } _mapCam.row = row; _mapCam.col = col; // restore previous inputs _Previnputs = _inputs; } }; The camera will also be updated. Class Buzzer This class required the pitches.h header private: uint8_t _in_pin,_rh_pin,_rl_pin;//inputs, reference high, reference low int _init_volt,_init_rh,_init_rl; //initial reading of each pin int _new_volt,_new_rh,_new_rl,_dVolt; // new input of each pin, and a change of voltage value int _old_volt=0; //old voltage value int _threshold = 15;//default threshold to ignore noise is 9 over 1024 volt float _shift_ratio=0; //the rati of voltage shift over the refrence voltage range as a linear scale from initial volts to new volts int _ref_range;// range of reference voltage , reference high - reference low bool _button_reg_set=0; //default assume release bool _edgetrigger=0; //edge trigger flag long _edgetiming=0; //edge trigger timing _in_pin , _rh_pin , _rl_pin , are the Dpad input pin, high voltage reference pin, low voltage reference pin respectively _init_volt , _init_rh , _init_rl , are the initialise reading, in Begin() from the input pin, high voltage reference pin, and low voltage reference pin respectively _new_volt , _new_rh , _new_rl are the new reading from the input pin, high voltage reference pin, and low voltage reference pin respectively _dVolt is a variable to calcualte the difference between two votlage reading _old_volt , is the _new_volt in the previous update _threshold define the deadband in which the program ignore the fluctuation of the voltage reading in the input pin _shift_ratio is a ratio to represent relative voltage change, the full equation wil be defined in Update() _ref_range is the variable used to store the value between the high and low reference voltage _button_reg_set is a flag is indicate whether a button is pressed, 0 is pressed, given input are pulled up _edgetrigger is the flag for an edge has been triggered _edgetiming is the timing when the edge triggered. :information_source: NOTE: might be neater to compress these pin reading into a data array, and the update operate could iterate through the variable instead of calling each variable individually. class Buzzer { private: uint8_t _buzz_pin; //which pin is the buzzer uint8_t _vol_pin; //the voltage of the buzzer (1 of two preset value) uint8_t _welcomeMelody[2] = {NOTE_B5,NOTE_A5}; // welcome tones uint8_t _welcomeMelodyDuration[2] = {250,250}; //duration for welcome tones Buzzer has 4 private variables; _buzz_pin contain the pin number for the buzzer _vol_pin , controls the MOSFET that boost the current to the buzzer _welcomeMelody is a two notes array that make noise when bootup, _welcomeMelodyDuration is the timer period for each note in the welcome tune public: //Constructor //constructor without volume pin Buzzer(uint8_t buzz_pin){ _buzz_pin = buzz_pin; } //constructor with both pin and volume Buzzer(uint8_t buzz_pin,uint8_t vol_pin){ _buzz_pin = buzz_pin; _vol_pin = vol_pin; } Two constructors Without volume control With volume control // play any single note void play_Note(int Note, int duration){ tone(_buzz_pin,Note,duration); } // play an array of notes int play_array(uint8_t Note_ary[], int note_len,uint8_t duration_ary[], int dura_len){ //check either of them are empty if(note_len==0||dura_len==0){ return 2; //type 2 error: empty inputs } // check if the duration matches the Note in size if (note_len != dura_len){ return 1; //type 1: error array doesn't matches } for (int playnote=0; playnote<note_len; playnote++){ //cychle thru each note in array with cooresponding duration tone(_buzz_pin,Note_ary[playnote],duration_ary[playnote]); } return 0; } Play note function only play one note with one duration Play array function cycle thru all the note in array and match the duration // rountine to play welcome tune void welcome(){ play_array(_welcomeMelody,2,_welcomeMelodyDuration,2); } // routine to play nothing void no_note(){ noTone(_buzz_pin); } The welcome() subroutine plays the welcome tune using play_array() There is a subroutine that play nothing // inistilising the buzzer pins void begin(){ pinMode(_buzz_pin, OUTPUT); pinMode(_vol_pin, OUTPUT); } Initialize class by setup buzz and volume pin as output in Arduino //write high void vol_HI(){ digitalWrite(_vol_pin, HIGH); } //write low void vol_LO(){ digitalWrite(_vol_pin, LOW); } }; vol_hi function connects the buzzer ground with a low resistor value using MOSFET, low resistor more current thus louder vol_lo function cut off the buzzer ground with a low resistor value using MOSFET Class Dpad_analog class Dpad_analog{ //digital Dpad would be separate to avoid excessive memory allocation public: byte status_reg = 0b11111100; //button inputs are pulled high //status reg that show which button is being pressed //NOTE: the full voltage of the DAC is about 82.6% of the uC HIGH output //constructor // 10 bits analog input version , CP-800 use this Dpad_analog(uint8_t input_pin, uint8_t ref_high_pin, uint8_t ref_low_pin){ _in_pin = input_pin; _rh_pin = ref_high_pin; _rl_pin = ref_low_pin; } Dpad status_reg records the status of the Dpad which are the 6 buttons inputs plus row and column shift enable bit at the end Constructor with inputs to _in_pins , two analog pin for the high logics voltage and low logics voltage void begin(){ pinMode(_in_pin, INPUT); pinMode(_rh_pin, INPUT_PULLUP); pinMode(_rl_pin, INPUT); _init_volt = analogRead(_in_pin); _init_rh = analogRead(_rh_pin); _init_rl = analogRead(_rl_pin); // _old_volt = _init_volt; //record init voltage input as previous voltage input } Initialisation routine define _in_pin as input, output from DAC IC _rh_pin as input pulled up, for high voltage _rl_pin as input, externally pulled down, for low voltage Read all inputs pin to initialize values // check if there is a update on Dpad inputs int checkupdate(){ return(_old_volt>_new_volt+_threshold || _old_volt<_new_volt-_threshold); } int Ispressed(){ return 1-_button_reg_set; //return 0 if pressed } The checkupdate() routine return 1 when new value is _threshold difference from the old values Ispressed() returns 0 when a button is pressed Future development Optimization of RAM usage Remove global variables that are not used More modularized code and use local variable. Better way to store tune and menu option (mainly const chr/int) More buttons and better structure button classes Currently the respond is are only 6 buttons, directions + AB, this should be expanded to respond to a more complex controller and allow more action from the user Allow a more efficient way to quick travel to another location or return to previous location, A systematic set of coordinates in the mapping might help. The structure for the mapping on the menu and cursor should remain separated, imagine the cursor is the user\u2019s character, and it is navigating the menu as if it is an RPG. Both the POV of the environment and the chr have to react to the user\u2019s inputs. Better ROM read/write addressing. Currently the ROM programs are referring to a set of fixed addresses. This could result in an imbalance number of read/write for some memory unit, and thus worn out those units quicker than others. New writing methods should consider the health of each ROM unit and maximize their life by using dynamic indexing, to avoid overwriting existing ROM units. The new method should also repeat old information in a new region. It would be ideal to reuse a step from another processing cycle than write a new step, since many step between different processing can be shared, such as rinse with water. maybe using wear leveling technique to use each ROM cell evenly. However, this might nullify the ROM.update() function where data is only update when there is a change to it Better still, to use a data compressing method that maximised reusing existing variables and trimmed data to be stored. Better code organization Tabs can be combined/separated according to their function/hardware/other arrangement There could be a classification of different header for different purpose, to further modalized the codes, this might allow an entire feature to be reuse in another project. UI Generise UIcursor and UImap with a navigation class that has position value","title":"Software"},{"location":"software/#software","text":"NOTE: this section needs a major overhaul, to make it more developer friendly The user manual has information regarding how to operate the machine. This document is for developers by explaining how the code functions and is structured. There are a lot of iterations of firmware that are applicable to the microcontroller in CP800. Much of the code is shared between all iteration of the firmware. This document will break the firmware by its function and explain each part of it. There is a log of changes written inside the beginning of the main code so developers track when a feature/function was implemented. Of course, that is not the most comprehensive log, so there might be changes that happened between the recorded date. For the sake of documentation, we assume all data recorded on the log is the date of a committed version of the firmware and all changes to between the commits happen on the latest commit.","title":"Software"},{"location":"software/#main-headers","text":"#define model \"CP-806\" #define version \"1.16.2\" #define PCBver 9 // sense =0 for NO sensor, and =1 for NC sensor #define OUTsense 0// change this to 1 when use the new flow sensor with the metal band and cable tie #define INsense 0 At the beginning of the code there is a section before the log. This section contains #define for the machine. \u201cmodel\u201d and \u201cversion\u201d are not used functionally as of 8th June 2022. However, PCBver is used to define the pinout for the Dpad and user interface inputs. Since there are two functional PCB being used by CP800 as of 8th June 2022. OUTsense and INsense, is used to defined whether the tank level sensor and flow out sensor are normally open (NO), or normally closed (NC) signal. In the future, more metadata could be defined here so other supporting software could identify the machine and hardware associated with that specific model and version of machine. //#define DEBUG //enable/disable serial debug output #ifdef DEBUG #define DEBUG_PRINT(x) Serial.print(x) #define DEBUG_PRINTDEC(x) Serial.print(x, DEC) #define DEBUG_PRINTbin(x,y) Serial.print(x, y) #define DEBUG_PRINTbinln(x,y) Serial.println(x, y) #define DEBUG_PRINTln(x) Serial.println(x) #else #define DEBUG_PRINT(x) #define DEBUG_PRINTDEC(x) #define DEBUG_PRINTbin(x,y) #define DEBUG_PRINTbinln(x,y) #define DEBUG_PRINTln(x) #endif #define DEBUG serial print via Arduino COM. This allows a global disable on all serial print functions when we don\u2019t want to be debugging. Note that there are still some serial.print functions not controlled by this declaration. void EditsParameters(int editIndex,int arrayIndex,int * Para,int push); There is one function declaration before the main. This function is used to edit existing processing in the ROM. This function required the following dependencies: The data type of ROMProgram struct And Arduino basic library. :information_source: NOTE: it is planned to modularize the ROM processing code to have a separate file and header. The section below the comment: // button assignment is for the position of each button on the Dpad to the R-2R DAC. Then the libraries are included below the line: // includes library Four libraries are active as of 8th June 2022 #include \"classes.h\" #include \"CP800.h\" #include <OneWire.h> #include <DallasTemperature.h> CP800.h and classes.h are defined within the Arduino script folder. LiquidCrystal , OneWire.h + DallasTemperature.h could be installed and updated with libraries manager on Arduino IDE. Following the comment: //pin assignment Are the pin assignments for most GPIO for joystick shield, SPI com, motor interface, valves interface, buzzer, fluid sensors. For the button variables: byte UIcommend; // debounced byte commend to the system from UI inputs byte UIinputs; // before debounced int de_button;// debounced signal from the Dpad buttons int editing = 0; // default program editing is off int menu_skipupdate=0; UIcommned , is the debounced 8 bits signal for the microcontroller, this includes the buttons digital inputs with the 6 MSBs. The 2nd LSB indicated whether the cursor can travel through the columns, whereas the LSB indicated whether the cursor can travel through the rows. UIinputs are the raw signal from the 6 inputs from Dpad de_button is the debounced signal for UIinputs Editing is a flag to indicate whether the user is in editing mode or not, see \u201cediting processing\u201d in the user manual. menu_skipupdate is a flag to control whether the menu is being updated or skipped. Might use a better name These variables are mainly interfacing with the UIcursor and UImap classes which contain the information where the cursor is on the menu, and where in the mapping of the menu. The final inputs are input to the buttonAction subroutine, where the microcontroller reacts to the new inputs every program cycle. //LCD #include <LiquidCrystal.h> #define rs 42 #define ee 43 #define d4 44 #define d5 45 #define d6 46 #define d7 47 //LCD Pin #define bl 36 LiquidCrystal lcd(rs, ee, d4, d5, d6, d7); For the LCD, a new library is included, LiquidCrystal.h , and a set of pin assignment is #define correspondingly to the object imitation of the LCD, see LiquidCrystal object constructor for how to initiate a LCD object with the library. char lcdBuff0[21]; char lcdBuff1[21]; char lcdBuff2[21]; char lcdBuff3[21]; char lcdBuffPrevious0[21]; char lcdBuffPrevious1[21]; char lcdBuffPrevious2[21]; char lcdBuffPrevious3[21]; The LCD screen used has 4 rows of 20 characters. Four lcdbuffer are made to store each position of the LCD. Four more are made to store the previous screen which are currently not used. //menu //menu structure see attached document int menuRow = 0; int menuColumn = 0; int infopage = 0; //there will be multiple info page as we expand the complexity const String menuTop[] = { //top tier menu text ...} const String menuSetting[] = { //declear settings menu ...} menuRow is the row number that the cursor/mapping is currently in menuColumn is the column number that the cursor/mapping is currently in Infopage is the page number that the user is currently viewing menuTop is a character array with words that are shown on the top menu menuSetting is a character array with words that are shown on the setting menu //edit menu int editIndex = 0; int editPara[19]; // edipara is a array, mostly will be only using the first entry int arrayIndex = 0; bool editmenuEnd=0; Three variables are declared under editing menu. These variables are used when the user is in editing ROM program mode. editIndex is the index that indicates the current variable the user is editing. Please see EditsParameters function to see how the entire processing program is flattened and how each data is indexed editPara is the value which the index is referring to. There are several types of datatypes, depending on the indexing the data in the array interpreted as different data type, please refer to EditsParameters function for future information arrayIndex is the index for the character array, processName[]. editmenuEnd is a flag for rather the edit menu reached the end or not //I/O Check bool outputCheckAction = 0; //Input/Output Check Mode bool IOCheckMode = 0; int IOIndex = 0; Three variables are declared to be used when the user is in the IO check mode in the setting menu, see user manual for how to navigate to the IOcheck menu outputCheckAction toggles the action state of each active element of the machine from the menu, typically the component is switched on when this value is 1, such as motor, pump, valve ...etc IOCheckMode indicates if the program is in the IO check menu. This enables the IOIndex to be changed, because the program has entered IO check mode IOIndex is the index that shows which input or output the user is currently checking. Refer to inputCheck() and outputCheck() to see how all inputs and outputs are arranged into an array. //declear process matrix String processPara[8][20] = { //6 process + 2 clean process {}, {}, {}, {}, {}, {}, {}, {} }; int processTemp[8] = {0, 0, 0, 0, 0, 0, 0, 0}; uint16_t processTime[8] = {0, 0, 0, 0, 0, 0, 0, 0}; uint8_t processTotalSteps[8] = {0, 0, 0, 0, 0, 0, 0, 0}; bool processParaSet[8] = {0, 0, 0, 0, 0, 0, 0, 0}; //process name String processName[6] = {\"---\", \"---\", \"---\", \"---\", \"---\", \"---\"}; processPara is an array of 8 with 20 strings each. String is used here because it is made using the old data format where all parameters are compiled into a String datatype processTemp is the temperature value for each process processTime is the duration of each process processTotalSteps is the number of steps in each process processParaSet is the flag that say whether the process has be set (loaded from storage) processName is the name of the process //processing data //timer unsigned long timer = 0; //system timer (mS) long timeJump = 0; //jump forward time for testing (mS) #define iniDelay 200 //delay in setup (mS) Then we will introduce all the data use in processing For timers: Long timer is a system timer where it will update every loop timeJump is an accumulated varaibles that will increase or decrease the timer values (currently unused) iniDelay is the delay amount in ms introduce in the for several component when machine is booting up. These include loading processes from ROM, initiating LED, initiating motor. //refresh timer for lcd etc. unsigned long refreshTimerA = 0; //timer for less frequent refresh (ms) unsigned long refreshTimerB = 0; //timer for frequent refresh (ms) #define refreshInterval 500 //time for lcd refresh (ms) refreshTimerA regulate what get update, currently it is at 4 times of refreshInterval which is 2s. These processes are LED, LCD, read temperature refreshTimerB regulates what get updated, currently it is at refresh interval rate which is 0.5s. These processes are controlling the motor, controlling the processing, or the cleaning process. //agitation byte agitationSpeed = 0; //0: ~20RMP 1: ~18RMP 2: ~16RPM unsigned long agitationTimer = 0; // S const int agitationTime1 = 10; // S const int agitationTime2 = 2; // S agitationSpeed determines the speed setting of the motor, this could be expanded to the values of a byte agitationTimer is not used agitationTime1 and agitationTime2 are used to create the pattern of motion during processing. The pattern is forward, stop, backward and stop, then repeat. //parameter of process bool processState; //process runing state (0:not running 1:running) int processNo; //runing process (0-7) bool steppingmode=0; //default =0 : sensor mode, 1= fixed timer unsigned long processStartTime = 0; //start time of current process processState is the flag showing whether the machine is running a processing or not processNo shows which process from the menu is selected to be processing steppingmode shows how the steps in a process are going to progress. Sensor mode means the step progress to the next step depending on the feedback sensor, fixed timer means the step progress to the next only depending on a fixed amount of time. processStartTime marks the timer instance where a new processing has begun. //parameter of clean process byte processStateClean; //process runing state for clean process (0: not runing 1: clean 1 process 2: clean 2 process) byte processCleanCycles; There are supposed to be two cleaning processes, they are both currently not programmed. From the order of adding and removing fluid. Clean 1 is having the both add and remove are active depending on a processing array. //parameters for current step bool stepState = 0; //step state (0: processing of this step is not done 1: processing of this step is done, ready to drain tank) String stepName[20] = {\"----\"}; uint8_t stepNo = 0; uint8_t stepIn[20]; //which port to add chem uint16_t stepTime[20]; //time for processing (S) uint8_t stepOut[20]; //which port to dump chem bool stepPush[20]; //if this step is subject to push/pull 0:no 1:yes bool flowin=0; bool flowout=0; int stepout = 0; // use to record what stepOut[stepNo] is, unused unsigned int stepTimer1 = 0; // begining of adding chem unsigned int stepTimer2 = 0; // beigning of process the drum, stopped adding chem unsigned int stepTimer3 = 0; // begining of removing chem, stpped the drum bool stepParaSet=0; //flag of step paratmeter are set, and ready to go //push/pull int push = 0; // the value of push/pull selected on the menu (this is loaded into the processing later) Within the processing, each step has timing and parameters that define their actions. stepState shows whether the processing of the film in this step is done, if done start draining tank fluid and prepare for the next step stepNo shows sequential order the step is in the processing StepName shows the name for a step stepIn and stepOut shows which valve port which are used in the step stepTime is the duration of the step stepPush enable/disable the step to be pushed/pulled. Push: increase time of processing of this step, pull: reduce time of processing of this step flowin is a flag made to force the chemical to flow in by the user at any time during the step which the processing is currently in flowout is a flag to force the chemical to flow out of port 6 during the process, this is used for emergency flow out in case the other valves are somehow blocked during the processing. Please refer to the user manual. Stepout is supposed to record the value of stepOut the processing was, so that an interrupted operation could be done and yet the processing could continue by pushing this variable back into stepOut (currently unused) stepTimer1 is use to time the adding chemical stage of the step stepTimer2 is use to time the rolling processing stage of the step stepTimer3 is use to time the removing chemical stage of the step stepParaSet shows whether the step parameters are loaded and ready to go push is the value of how much time are increase/decrease (push or pull) for all the pushable steps in the current processing //error Message String errorMessage = \"\"; unsigned long int popuptimer=0; errorMessage is a String for displaying the message when an error incurred popuptimer is a time variable for displaying a message on LCD, this is updated to the newest time, so the popup message will display for a duration of time after this variable is updated #include <EEPROM.h> int strByteLen = 200; //String Length limit in bytes int addrShift = 0; //to shift byte for wear leveling EEPROM is one of the options to store and recall processing, all parameters are stored as a byte array. strByteLen is currently defined as 200 bytes. Detailed structure of the stored array is in the comment section of the CP800.h tab. addrShift is supposed to be a random 8 bits value that shifts the ROM address, in order to achieve wear leveling. The array will have a wrapping order from 256 back to 0. However, the wrapping is not yet programmed. Currently not use. #include <SD.h> #include <SPI.h> #include <stdlib.h> int SD_err =0; // 0: no err, 1: SD.begin error, 2: file load err, 3: step data load err int program_no = 0; // count the number of program stored in the SD card file int loadtype=0; // 1 is SD, and 0 is ROM, default from ROM int validROMprogram[6] = {1,1,1,1,1,1}; //0: invalid, 1:valid Load all libraries required to use SD module on Arduino SD_err is the value that returns from attempt to initiate the SD module program_no is the number of processing program stored on the SD card; the program indicator is located at the beginning of each processing program. More details for the data structured store on SD card are described in \u201cprocess_data\u201d tab loadtype determines how processing program is loaded, either from SD card or EEPROM validROMprogram is an array of flags to indicate which programs stored in the EEMPROM have a valid data structure. If there is no legit program header found in each memory slot, the function will change this array of the corresponding index to 0, so loading on those program entries will be skipped. //digital Temperature Sensor #define tempPin 27 //DS18B20 signal bus OneWire oneWire(tempPin); //Temperature chip i/o DallasTemperature sensors(&oneWire); //Temperature Control float tempCurrent = -10.0; float tempTarget = 22.0; Currently temperature is not use in anyway. This is merely a template for future expansion for now.","title":"Main Headers"},{"location":"software/#define-pin-27-to-be-the-onewire-bus","text":"Instantiation of the onewire object to be the define above Instantiation of the dallas temperature sensor to be the one wire bus device tempCurrent and tempTarget are the current and target temperature of the sensor. tempCurrent actually doesn\u2019t need initialization. //instanstation of object Led Led(LED_woke); Buzzer buzz(buzz_pin,volume_pin); SixWay_valve addChem(add_s0,add_s1,add_s2,add_pump); SixWay_valve removeChem(remove_s0,remove_s1,remove_s2,remove_pump); agitationMotor agitationMotor(motor_on, motor_dir, motor_PWM); bathPump bathPump(soak_pump); //tankLevel tankLevel; //soakLevel soakLevel; digilevel drumHI(drum_high,LEVEL_SAMPLE_SIZE, INsense ); digilevel drumempty(drum_empty,LEVEL_SAMPLE_SIZE, OUTsense); //analoglevel chemtanks_full(); //analoglevel chemtanks_half(); //analoglevel chemtanks_low(); analoglevel soakLevel(tanks_full,LEVEL_SAMPLE_SIZE); AC_heater heater(heat_PWM); joystick joystick(KEYA,KEYB,KEYC,KEYD, KEYK, JOYX, JOYY); Dpad_analog panel_UI(Dpad_in_pin, Dpad_refH_pin, Dpad_refL_pin); UIcursor user_navi(&UIcommend); UImap menu_navi(&UIcommend); Now we instantiate all objects needed to operate the machine with the variable we declared previously: LED Buzzer 6ways valve for both inlet and outlet Motor Bathpump, currently no corresponding hardware Digital level sensor for inside the tank and along the outlet tube Analog level sensors are not used The heating element using AC power Joystick shield Dpad interface as the UI The cursor location on the screen is the user The location displayed on the screen is the menu","title":"define pin 27 to be the onewire bus"},{"location":"software/#cp800h","text":"This header tab is made to contains classes and global variable for those classes in the CP800 series #include \"pitches.h\" #define arrayLength(array) (sizeof((array))/sizeof((array)[0])) #include <LiquidCrystal.h> #include <EEPROM.h> Libraries used in the classes : pitches.h , EEPROM.h , LiquidCrystal.h pitches.h : has the buzzer value to make different notes and function to generate pre-defined tune LiquidCrystal is the library for display on the LCD EEPROM is the library for accessing the EEPROM on Arduino arrayLength is to calculate the size of an array using sizeof() bool zero_crossed=0; int maxcol=3; //maximum number of col to be display (shift colume by left and right) int rowstack[8][2];//a matrix that stored the row value for both the user cursor and the menu map int colstack[8][2]; //a matrix that stored the col value for both the user cursor and the menu map int actionstack; // the variable to restore which action the menu is selected String lcdStr[4] = {\"\", \"\", \"\", \"\"}; int ispageEnd = 0; //flag indicaitng the end of the menu page int pagerow = 4; //default is four zero_crossed is the flag to indicate whether the AC input of the heating has crossed zero. This allows a fixed energy cycle for the PWM cycle within a certain time error maxcol is the variable that allows users to shift left and right in the menu to see different information rowstack is the data matrix that stored the row coordinate of both the user cursor and menu map colstack is the data matrix that stored the column coordinate of both the user cursor and menu map actionstack is the value for the action that the machine is taking, this is normally on the last page in the menu, where the user has to pick a function or run a program. The previously two stacks are for the location of the menu through each layer of the selection on the menu. lcdStr is the array of 4 strings to be displayed on the LCD ispageEnd is the flag for indicating the menu had reached an end page, a page where you have to select an action and no more option to be select after that pagerow is the number of rows on the current menu page. Usually 4 rows, given the screen has 4 rows, but main menu and program selection has more, and allow scrolling down //this is the view in which the LCD is looking at struct camera{ int col; int row; int row_size; int col_size; }; The camera struct contain the coordinate of the camera and the size in each dimension to be seen by the camera. Imagine it to be the view range of a person on the map.","title":"CP800.h"},{"location":"software/#class-uicursor","text":"class UIcursor { private: byte* _inputsRef; byte _inputs; byte _Previnputs; int _rowlimit=3; Private variables include: _inputsRef is the pointer to the input variable _inputs is the variable that take the new inputs _previnputs is the variable that stored the previous inputs _rowlimit is restricted to row 3 (4th row) , because cursor cannot move out of the screen void limit(int *row, int *col){ if (*row>_rowlimit) *row=_rowlimit; if (*row<0) *row=0; if (*col<0) *col=0; } The private function limit() restricts the value of row and column between 0 to the upperlimit , so far only row has an upper limit for the cursor public: int row=0; int col=0; int layer=0; row , col , layer fully describe the location of the cursor on the map //pass the input pointer to the private variable UIcursor (byte* inputs){ _inputsRef = inputs; } Instantiate the class by passing a pointer of a byte void begin(){ //initiate inputs _inputs = *_inputsRef; //when begin, load the value of the input pointer to _inputs _Previnputs = _inputs; // initailise the previous as current inputs Initialize the class by taking the input from the pointer and make previous input the same // can overwrite the current location of the cursor to any positon on the map void wrappoint (int wraprow, int wrapcol, int wraplayer){ row=wraprow; col=wrapcol; layer=wraplayer; } Public function to edit the current location of the cursor to any value // update cursor from the inputs given the number of row to be displayed and wehter it is a end page void Update(int isEnd, int displayrow){ _inputs = *_inputsRef; _rowlimit = displayrow-1; // shift between menu layr with A and B // ULRDAB bool A = (_Previnputs>>A_shift & 1) & ~(_inputs>>A_shift & 1); bool B = (_Previnputs>>B_shift & 1) & ~(_inputs>>B_shift & 1); if (A){ rowstack[layer][2] =row; colstack[layer][2] =col; //stop incrementing if page is an end page if (isEnd!=1){ rowstack[layer][2] =row; layer +=1; // new coordinate for new layer }else{ actionstack = row; // which row is pressed on the action page/end page } // return row and col anyway after pressing A, too hard to see respawn without changes, updated 202011130 row = 0; col = 0; if(layer>3)layer=3; }else if (B){ //use 0 to destroy the layer for returning operation rowstack[layer][2] = 0; colstack[layer][2] = 0; layer -=1; if(layer<0)layer=0; row = rowstack[layer][2]; col = colstack[layer][2]; //clear after unloading into the cursor positoin rowstack[layer][2] = 0; colstack[layer][2] = 0; }else{ The update function is the core function of the class. It updates the position of the cursor by reading and interpreting the buttons inputs, when the update is called. The button shift defined in header will now be used to isolate the A and B button, these buttons confirm or cancel an action. When press A: Stored the current row and column position to the stack If this is the end page, row value is the action option, if not, we increment the layer Then reset row and column position to 0 as we are either doing a new action, Since no page is beyond layer 3, restrict layer increment when reached end, this could be redundant if mapping and tracking is done better When press B: Reset current position to zero in stack Decrement layer Load previous layer position Clear the previous location from stack }else{ /* * row increment when the down button signal transit from 1 to 0 * row decrement when the up button signal transite from 1 to 0 * * commend switch to col if the menu allow colum * * non blocking operation for all direction (could be using in game mode) * ULRDAB */ row += (_Previnputs>>Down_shift & 1) & ~(_inputs>>Down_shift & 1) & _inputs& 1; row -= (_Previnputs>>Up_shift & 1) & ~(_inputs>>Up_shift & 1) & _inputs& 1; // we may not need col position for the cursor col += (_Previnputs>>Right_shift & 1) & ~(_inputs>>Right_shift & 1) & (_inputs>>1 & 1); col -= (_Previnputs>>Left_shift & 1) & ~(_inputs>>Left_shift & 1) & (_inputs>>1 & 1); limit(&row,&col); } // restore previous inputs _Previnputs = _inputs; } }; When press other buttons Increment or decrement row value if press up and down while row shift bit is enabled ( _inputs&1 ) Increment or decrement column value if press left and right while row shift bit is enabled ( _inputs>>1&1 ) Check and limit row and column according to the boundary of the menu page Always, update input to previous input at the end","title":"Class UIcursor"},{"location":"software/#class-uimap","text":"This class is very similar to UIcursor , in fact, it could be position to generalise both UImap and UIcursor class into one class. class UImap{ private: //map has a camera datatype to contain the dispaly size and location of the menu camera _mapCam; byte* _inputsRef; byte _inputs; byte _Previnputs; int _rowlimit=3; //default typical 4 row, 0-3 void limit(int *row, int *col){ if (*row>_rowlimit) *row=_rowlimit; if (*row<0) *row=0; if (*col<0) *col=0; All except the inclusion of camera struct is the same as UIcursor . Camera structs allow UImap not only the position but the range of location that is visible void begin(){ _mapCam.row=0; //start at the top _mapCam.col=0; //start at the left _mapCam.row_size = 4; //default dispalying 4 row of character _mapCam.col_size = 19;//default dispalying 19 character //initiate inputs _inputs = *_inputsRef; _Previnputs = _inputs; } Initialize class with camera values, and camera sizes are fixed void wrappoint (int wraprow, int wrapcol, int wraplayer) Exact same function as UIcursor void Update(int isEnd, int displayrow){ _inputs = *_inputsRef; _rowlimit = displayrow-1; // shift between menu layr with A and B bool A = (_Previnputs>>A_shift & 1) & ~(_inputs>>A_shift & 1); bool B = (_Previnputs>>B_shift & 1) & ~(_inputs>>B_shift & 1); if (A){ colstack[layer][1] =col; if (isEnd!=1){ rowstack[layer][1] =row; layer +=1; // new coordinate for new layer row = 0; col = 0; }else{ actionstack = row; } if(layer>3)layer=3; Update mirror the UIcursor }else{ /* row += (_Previnputs>>Down_shift & 1) & ~(_inputs>>Down_shift & 1) & _inputs& 1; row -= (_Previnputs>>Up_shift & 1) & ~(_inputs>>Up_shift & 1) & _inputs& 1; // we may not need col position for the cursor col += (_Previnputs>>Right_shift & 1) & ~(_inputs>>Right_shift & 1) & (_inputs>>1 & 1); col -= (_Previnputs>>Left_shift & 1) & ~(_inputs>>Left_shift & 1) & (_inputs>>1 & 1); limit(&row,&col); } _mapCam.row = row; _mapCam.col = col; // restore previous inputs _Previnputs = _inputs; } }; The camera will also be updated.","title":"Class UImap"},{"location":"software/#class-buzzer","text":"This class required the pitches.h header private: uint8_t _in_pin,_rh_pin,_rl_pin;//inputs, reference high, reference low int _init_volt,_init_rh,_init_rl; //initial reading of each pin int _new_volt,_new_rh,_new_rl,_dVolt; // new input of each pin, and a change of voltage value int _old_volt=0; //old voltage value int _threshold = 15;//default threshold to ignore noise is 9 over 1024 volt float _shift_ratio=0; //the rati of voltage shift over the refrence voltage range as a linear scale from initial volts to new volts int _ref_range;// range of reference voltage , reference high - reference low bool _button_reg_set=0; //default assume release bool _edgetrigger=0; //edge trigger flag long _edgetiming=0; //edge trigger timing _in_pin , _rh_pin , _rl_pin , are the Dpad input pin, high voltage reference pin, low voltage reference pin respectively _init_volt , _init_rh , _init_rl , are the initialise reading, in Begin() from the input pin, high voltage reference pin, and low voltage reference pin respectively _new_volt , _new_rh , _new_rl are the new reading from the input pin, high voltage reference pin, and low voltage reference pin respectively _dVolt is a variable to calcualte the difference between two votlage reading _old_volt , is the _new_volt in the previous update _threshold define the deadband in which the program ignore the fluctuation of the voltage reading in the input pin _shift_ratio is a ratio to represent relative voltage change, the full equation wil be defined in Update() _ref_range is the variable used to store the value between the high and low reference voltage _button_reg_set is a flag is indicate whether a button is pressed, 0 is pressed, given input are pulled up _edgetrigger is the flag for an edge has been triggered _edgetiming is the timing when the edge triggered. :information_source: NOTE: might be neater to compress these pin reading into a data array, and the update operate could iterate through the variable instead of calling each variable individually. class Buzzer { private: uint8_t _buzz_pin; //which pin is the buzzer uint8_t _vol_pin; //the voltage of the buzzer (1 of two preset value) uint8_t _welcomeMelody[2] = {NOTE_B5,NOTE_A5}; // welcome tones uint8_t _welcomeMelodyDuration[2] = {250,250}; //duration for welcome tones Buzzer has 4 private variables; _buzz_pin contain the pin number for the buzzer _vol_pin , controls the MOSFET that boost the current to the buzzer _welcomeMelody is a two notes array that make noise when bootup, _welcomeMelodyDuration is the timer period for each note in the welcome tune public: //Constructor //constructor without volume pin Buzzer(uint8_t buzz_pin){ _buzz_pin = buzz_pin; } //constructor with both pin and volume Buzzer(uint8_t buzz_pin,uint8_t vol_pin){ _buzz_pin = buzz_pin; _vol_pin = vol_pin; } Two constructors Without volume control With volume control // play any single note void play_Note(int Note, int duration){ tone(_buzz_pin,Note,duration); } // play an array of notes int play_array(uint8_t Note_ary[], int note_len,uint8_t duration_ary[], int dura_len){ //check either of them are empty if(note_len==0||dura_len==0){ return 2; //type 2 error: empty inputs } // check if the duration matches the Note in size if (note_len != dura_len){ return 1; //type 1: error array doesn't matches } for (int playnote=0; playnote<note_len; playnote++){ //cychle thru each note in array with cooresponding duration tone(_buzz_pin,Note_ary[playnote],duration_ary[playnote]); } return 0; } Play note function only play one note with one duration Play array function cycle thru all the note in array and match the duration // rountine to play welcome tune void welcome(){ play_array(_welcomeMelody,2,_welcomeMelodyDuration,2); } // routine to play nothing void no_note(){ noTone(_buzz_pin); } The welcome() subroutine plays the welcome tune using play_array() There is a subroutine that play nothing // inistilising the buzzer pins void begin(){ pinMode(_buzz_pin, OUTPUT); pinMode(_vol_pin, OUTPUT); } Initialize class by setup buzz and volume pin as output in Arduino //write high void vol_HI(){ digitalWrite(_vol_pin, HIGH); } //write low void vol_LO(){ digitalWrite(_vol_pin, LOW); } }; vol_hi function connects the buzzer ground with a low resistor value using MOSFET, low resistor more current thus louder vol_lo function cut off the buzzer ground with a low resistor value using MOSFET","title":"Class Buzzer"},{"location":"software/#class-dpad_analog","text":"class Dpad_analog{ //digital Dpad would be separate to avoid excessive memory allocation public: byte status_reg = 0b11111100; //button inputs are pulled high //status reg that show which button is being pressed //NOTE: the full voltage of the DAC is about 82.6% of the uC HIGH output //constructor // 10 bits analog input version , CP-800 use this Dpad_analog(uint8_t input_pin, uint8_t ref_high_pin, uint8_t ref_low_pin){ _in_pin = input_pin; _rh_pin = ref_high_pin; _rl_pin = ref_low_pin; } Dpad status_reg records the status of the Dpad which are the 6 buttons inputs plus row and column shift enable bit at the end Constructor with inputs to _in_pins , two analog pin for the high logics voltage and low logics voltage void begin(){ pinMode(_in_pin, INPUT); pinMode(_rh_pin, INPUT_PULLUP); pinMode(_rl_pin, INPUT); _init_volt = analogRead(_in_pin); _init_rh = analogRead(_rh_pin); _init_rl = analogRead(_rl_pin); // _old_volt = _init_volt; //record init voltage input as previous voltage input } Initialisation routine define _in_pin as input, output from DAC IC _rh_pin as input pulled up, for high voltage _rl_pin as input, externally pulled down, for low voltage Read all inputs pin to initialize values // check if there is a update on Dpad inputs int checkupdate(){ return(_old_volt>_new_volt+_threshold || _old_volt<_new_volt-_threshold); } int Ispressed(){ return 1-_button_reg_set; //return 0 if pressed } The checkupdate() routine return 1 when new value is _threshold difference from the old values Ispressed() returns 0 when a button is pressed","title":"Class Dpad_analog"},{"location":"software/#future-development","text":"Optimization of RAM usage Remove global variables that are not used More modularized code and use local variable. Better way to store tune and menu option (mainly const chr/int) More buttons and better structure button classes Currently the respond is are only 6 buttons, directions + AB, this should be expanded to respond to a more complex controller and allow more action from the user Allow a more efficient way to quick travel to another location or return to previous location, A systematic set of coordinates in the mapping might help. The structure for the mapping on the menu and cursor should remain separated, imagine the cursor is the user\u2019s character, and it is navigating the menu as if it is an RPG. Both the POV of the environment and the chr have to react to the user\u2019s inputs. Better ROM read/write addressing. Currently the ROM programs are referring to a set of fixed addresses. This could result in an imbalance number of read/write for some memory unit, and thus worn out those units quicker than others. New writing methods should consider the health of each ROM unit and maximize their life by using dynamic indexing, to avoid overwriting existing ROM units. The new method should also repeat old information in a new region. It would be ideal to reuse a step from another processing cycle than write a new step, since many step between different processing can be shared, such as rinse with water. maybe using wear leveling technique to use each ROM cell evenly. However, this might nullify the ROM.update() function where data is only update when there is a change to it Better still, to use a data compressing method that maximised reusing existing variables and trimmed data to be stored. Better code organization Tabs can be combined/separated according to their function/hardware/other arrangement There could be a classification of different header for different purpose, to further modalized the codes, this might allow an entire feature to be reuse in another project. UI Generise UIcursor and UImap with a navigation class that has position value","title":"Future development"},{"location":"advanced/arduino_process_gen/","text":"Instruction: writing program with Arduino script This is for developers and makers only; the SD card should be programmed with a more user-friendly method such as web apps. this Arduino script used to program the SD card is for generating examples for testing the functionality of loading programs from Sd card, as the name suggests, it is made to test to store program on SD cards. Please locate the arduino code: test_storeProgams.ino , and make a copy for you to change the programs. Keep the original file, so it is a backup. Please follow the hookup guide to setup the hardware and Arduino before you make a change to the script. We are using the big SD module, but they all work in the same way as long as they are hooked up correctly for the SPI communication. https://randomnerdtutorials.com/guide-to-sd-card-module-with-arduino/ https://create.arduino.cc/projecthub/electropeak/sd-card-module-with-arduino-how-to-read-write-data-37f390 Step 1: Setup the constants There are three sections of constants you need to define just after the headers The first set is the pin assignment for the SD card port, please refer to the Arduino board for the pin number of the SPI communication The second section only has one constant that is the name of the file where you stored the programs, on default it should be a misspelt document called \"progroms.txt\", this file could also be renamed later use a PC by editing the filename. The last section is the file specific constant, these describe the general configuration for all the programs hold in this file The constant of numberofprogram indicates the number of programs you wish to store in the fie. The constant array of stepName is a lookup table for the stepCode to indicate what each step is in each process, please expand the list of stepName with as many variations of step you have on your machine. Step 2: filling in the parameters There are two set of parameters that need to be filled out, one set is for each processprogram on the programlist. These parameters describe the processes of all programs in the files. The structure of processProgram contain a processName , the duration of the entire process, the number of steps in the process, and the temperature of the entire process, following by the pointer to an array of process steps that contain the parameters of each step. Change these parameter is the setup() section of the code. ProcessProgram should be right after Serial.begin(115200) ; Name your program within the ProgramList array for each processName variable. This could be any name as long as it is below 20 characters long NOTE: due to the constraint of the memory on the Arduino, it could only load up to 6 different programs, so ProgramList[6] and ProgramList[7] will never get use. for each program, type the duration in second to the duration variable in each ProgramList . Min value: 0, max value: 65,535 type the number of step for each program on ProgramList array. Min value: 1, max value: 255 type the temp for each program on ProgramList array. Min value: 1, max value: 255 There is no need to define the processes now, we will do it in the next section. The other set is for each step within each program on the program list. In each step of the process, the step contains the stepcode where stepName[stepcode] return the name of the step, the input tank number, the duration of the step where the film is bath in the chemical, and the output tank number, and a flag to indicate whether the step can be push/pull. Please copy and paste each line for the variables: stepcode , inputtank , outputtank , duration , push to the number of steps you define in the program section. And then change the value of each variable within the structure. The default code contains 8 different programs and the value for the parameters are placeholder values. Please add more by copy and pasting the entire list of steps for each program to the number of programs you defined in Step 1. Please remember to change the index of ProgramList so you are writing a new program in the list not overwrite the old one you copied the list of steps from. For each step, the 5 variables of each step have to be filled within each program. The index should be consistent with the number of steps you defined in the respective index of program on the ProgramList. The default should be a long list of placeholder values. Please edit the code so that the index of process is consistent with the numberofstep variable defined. None of the step should be skipped or left blank. These steps should be repeated for each program on the ProgramList. 1) Step code is the code representing the name of the step from the stepName[] array defined in Step 1. min value: 0, max value: 255 2) inputtank is the solenoid valve you want your step to use for the input chemical, CP800 only has 6 input port, so the valid range of value is 1-6 inclusive, any other number will cause error. min value: 1, max value: 6 3) outputtank is the solenoid valve you want your step to use for the output chemical, CP800 only has 6 input port, so the valid range of value is 1-6 inclusive, any other number will cause error. min value: 1, max value: 6 4) Duration is the duration for the step, do not confuse it with the duration for the program you defined for the program. Min value: 0, max value: 65,535 5) Push indicate whether the step is pushable, 0 mean no, and 1 is yes. If the step is pushable, the push and pull value given before the start of the processing will affect the duration of this step, only accept 0 or 1 value, anything bigger than 1 is equal to 1. min value:0, max value:1","title":"Writing programs with Arduino script"},{"location":"advanced/arduino_process_gen/#instruction-writing-program-with-arduino-script","text":"This is for developers and makers only; the SD card should be programmed with a more user-friendly method such as web apps. this Arduino script used to program the SD card is for generating examples for testing the functionality of loading programs from Sd card, as the name suggests, it is made to test to store program on SD cards. Please locate the arduino code: test_storeProgams.ino , and make a copy for you to change the programs. Keep the original file, so it is a backup. Please follow the hookup guide to setup the hardware and Arduino before you make a change to the script. We are using the big SD module, but they all work in the same way as long as they are hooked up correctly for the SPI communication. https://randomnerdtutorials.com/guide-to-sd-card-module-with-arduino/ https://create.arduino.cc/projecthub/electropeak/sd-card-module-with-arduino-how-to-read-write-data-37f390","title":"Instruction: writing program with Arduino script"},{"location":"advanced/arduino_process_gen/#step-1-setup-the-constants","text":"There are three sections of constants you need to define just after the headers The first set is the pin assignment for the SD card port, please refer to the Arduino board for the pin number of the SPI communication The second section only has one constant that is the name of the file where you stored the programs, on default it should be a misspelt document called \"progroms.txt\", this file could also be renamed later use a PC by editing the filename. The last section is the file specific constant, these describe the general configuration for all the programs hold in this file The constant of numberofprogram indicates the number of programs you wish to store in the fie. The constant array of stepName is a lookup table for the stepCode to indicate what each step is in each process, please expand the list of stepName with as many variations of step you have on your machine.","title":"Step 1: Setup the constants"},{"location":"advanced/arduino_process_gen/#step-2-filling-in-the-parameters","text":"There are two set of parameters that need to be filled out, one set is for each processprogram on the programlist. These parameters describe the processes of all programs in the files. The structure of processProgram contain a processName , the duration of the entire process, the number of steps in the process, and the temperature of the entire process, following by the pointer to an array of process steps that contain the parameters of each step. Change these parameter is the setup() section of the code. ProcessProgram should be right after Serial.begin(115200) ; Name your program within the ProgramList array for each processName variable. This could be any name as long as it is below 20 characters long NOTE: due to the constraint of the memory on the Arduino, it could only load up to 6 different programs, so ProgramList[6] and ProgramList[7] will never get use. for each program, type the duration in second to the duration variable in each ProgramList . Min value: 0, max value: 65,535 type the number of step for each program on ProgramList array. Min value: 1, max value: 255 type the temp for each program on ProgramList array. Min value: 1, max value: 255 There is no need to define the processes now, we will do it in the next section. The other set is for each step within each program on the program list. In each step of the process, the step contains the stepcode where stepName[stepcode] return the name of the step, the input tank number, the duration of the step where the film is bath in the chemical, and the output tank number, and a flag to indicate whether the step can be push/pull. Please copy and paste each line for the variables: stepcode , inputtank , outputtank , duration , push to the number of steps you define in the program section. And then change the value of each variable within the structure. The default code contains 8 different programs and the value for the parameters are placeholder values. Please add more by copy and pasting the entire list of steps for each program to the number of programs you defined in Step 1. Please remember to change the index of ProgramList so you are writing a new program in the list not overwrite the old one you copied the list of steps from. For each step, the 5 variables of each step have to be filled within each program. The index should be consistent with the number of steps you defined in the respective index of program on the ProgramList. The default should be a long list of placeholder values. Please edit the code so that the index of process is consistent with the numberofstep variable defined. None of the step should be skipped or left blank. These steps should be repeated for each program on the ProgramList. 1) Step code is the code representing the name of the step from the stepName[] array defined in Step 1. min value: 0, max value: 255 2) inputtank is the solenoid valve you want your step to use for the input chemical, CP800 only has 6 input port, so the valid range of value is 1-6 inclusive, any other number will cause error. min value: 1, max value: 6 3) outputtank is the solenoid valve you want your step to use for the output chemical, CP800 only has 6 input port, so the valid range of value is 1-6 inclusive, any other number will cause error. min value: 1, max value: 6 4) Duration is the duration for the step, do not confuse it with the duration for the program you defined for the program. Min value: 0, max value: 65,535 5) Push indicate whether the step is pushable, 0 mean no, and 1 is yes. If the step is pushable, the push and pull value given before the start of the processing will affect the duration of this step, only accept 0 or 1 value, anything bigger than 1 is equal to 1. min value:0, max value:1","title":"Step 2: filling in the parameters"},{"location":"circuit/","text":"Description The CP800 circuit is designed to fulfil the function of developing films with drum rolling and it consists of the following requirements 1) Control the fluid flow of developing film 2) Control the temperature of the fluid 3) Control the motor for the rolling action 4) User interface List of features in planning Please read this in conjunction with the software plan, since back-end development of the software will be highly tied with the hardware development. Multiple heating element array control, if each storage chemical needs to be kept at a different temperature Temperature PID controller (software) Allow the use of 100VAC, there will be a transformer to step down higher AC voltage to 100VAC, this allows the machine to work in country with a different phase voltage, by converting them all to 100VAC. Program the microcontroller to control the backlight of the LCD screen if required. (software) Program that allows a selection to read from the digital input of the Dpad via the serial output from the shift register. (software) Implement an on and off software button using the LED button mounted on the Dpad. (software) Earth all solenoid to a common point. Overvoltage and undervoltage protection Quick self-diagnosis button or additional debugging display (led on communication...etc) Float sensor feedback for each storage tank","title":"Description"},{"location":"circuit/#description","text":"The CP800 circuit is designed to fulfil the function of developing films with drum rolling and it consists of the following requirements 1) Control the fluid flow of developing film 2) Control the temperature of the fluid 3) Control the motor for the rolling action 4) User interface","title":"Description"},{"location":"circuit/#list-of-features-in-planning","text":"Please read this in conjunction with the software plan, since back-end development of the software will be highly tied with the hardware development. Multiple heating element array control, if each storage chemical needs to be kept at a different temperature Temperature PID controller (software) Allow the use of 100VAC, there will be a transformer to step down higher AC voltage to 100VAC, this allows the machine to work in country with a different phase voltage, by converting them all to 100VAC. Program the microcontroller to control the backlight of the LCD screen if required. (software) Program that allows a selection to read from the digital input of the Dpad via the serial output from the shift register. (software) Implement an on and off software button using the LED button mounted on the Dpad. (software) Earth all solenoid to a common point. Overvoltage and undervoltage protection Quick self-diagnosis button or additional debugging display (led on communication...etc) Float sensor feedback for each storage tank","title":"List of features in planning"},{"location":"circuit/planned_features/","text":"List of features in planning: Please read this in conjunction with the software plan, since back-end development of the software will be highly tied with the hardware development. Multiple heating element array control, if each storage chemical needs to be kept at a different temperature Temperature PID controller (software) Allow the use of 100VAC, there will be a transformer to step down higher AC voltage to 100VAC, this allows the machine to work in country with a different phase voltage, by converting them all to 100VAC. Program the microcontroller to control the backlight of the LCD screen if required. (software) Program that allows a selection to read from the digital input of the Dpad via the serial output from the shift register. (software) Implement an on and off software button using the LED button mounted on the Dpad. (software) Earth all solenoid to a common point. Overvoltage and undervoltage protection Quick self-diagnosis button or additional debugging display (led on communication...etc) Float sensor feedback for each storage tank","title":"List of features in planning:"},{"location":"circuit/planned_features/#list-of-features-in-planning","text":"Please read this in conjunction with the software plan, since back-end development of the software will be highly tied with the hardware development. Multiple heating element array control, if each storage chemical needs to be kept at a different temperature Temperature PID controller (software) Allow the use of 100VAC, there will be a transformer to step down higher AC voltage to 100VAC, this allows the machine to work in country with a different phase voltage, by converting them all to 100VAC. Program the microcontroller to control the backlight of the LCD screen if required. (software) Program that allows a selection to read from the digital input of the Dpad via the serial output from the shift register. (software) Implement an on and off software button using the LED button mounted on the Dpad. (software) Earth all solenoid to a common point. Overvoltage and undervoltage protection Quick self-diagnosis button or additional debugging display (led on communication...etc) Float sensor feedback for each storage tank","title":"List of features in planning:"},{"location":"circuit/v0_9/","text":"V0.9 The original working prototype for CP800 The function of the board is broken down into the following sections: 1) The power transfer to each of the components below 2) The pumps 3) The motor 4) The fluid sensors feedback 5) The solenoid valves for flow control 6) The user interface 7) The heating element Power circuit Both 12V and 5V comes from the external switch converter and are reverse polarity protected with low on resistance p-channel MOSFET and Zener diode. The Arduino is powered via the 5V pin bypassing the LDO that required a higher voltage to power. And all 12V and 5V components will be supplied by these two voltage sources. There are four power connectors, one is the input from the 12V PSU, one is the 12V output after the reverse polarity protection, one is 5V voltage input from the buck converter, and the last one is an extra header for a 5V reference. Pumps control There are three output ports for pumps. They are 2pin output. Each pump is driven by a power MOSFET to switch them on and off with a low side BJT transistor as the gate driver. A high output in the microcontroller will allow gate to discharge thru the BJT quickly, and achieve a faster turn off of the pumps. Meanwhile, a low output on the microcontroller will turn the BJT off, and the MOSFET gate is charged thru the low resistance pull up resistor, to achieve a regulated turn on time. The pull up resistor in the microcontroller signal pin is implemented in the case where these pins are not programmed. The pull up resistors will ensure the pump is off when these pins are not programmed. Fuses are installed to prevent over current, and a flyback Schottky diode is used to limit voltage surge by the induction load from the pumps. Motor Control The motor control is very similar to the pump control as they are both inductions loading presumably. The motor we are using has 5 pins control: PWR, DIR, PWN, FB, GND. We don't use the current feedback wire, so it is left out of the port output intentionally. The motor is then connected to the 4 pins JST XH output on the board. In order to turn on the motor, we need the PWE pin to be 12V, and the GND pin to be 0V. There is a fuse of the appropriate current to limit over current, and there is a flyback Schottky diode to limit voltage surge. Both DIR and GND pins are controlled by power MOSFETs to switch between 12V and 0V. A pulled up resistor of 12V is in place for the DIR pin, so there is a default DIR of rotation for the motor, if the pin is left hanging. The low side BJT allows a quick discharge of gate, and the low resistance pull up allows a fixed time fast charging up to the gate. The pulled up in the microcontroller pins are to make sure the DIR and 0V pin are forced to 12V and keep the motor off, if these pins are not programmed by the microcontroller. Solenoid valves control Both add and remove valves are controlled in the same way. Since solenoid is a highly inductive load, we have to apply a voltage of 12V across each pair of contact on the solenoid block. Similar to motor and pumps, a fuse to protect from over current and flyback Schottky diode for voltage surge. Each solenoid is switched on and off by a MOSFET with a low side BJT driver for fast drain in gate and a pulled-up resistor in case of unprogrammed microcontroller pins to the demultiplexer, CD4051. User interface There are two connectors between the motherboard and the Dpad board. These control the user interface. The 10ways IDC connector is the connection with each button and LED on the Dpad. The 10ways JST XH header is the signal going to the LCD screen. The screen is turned on and off by MOSFET, the program is currently locked to stay on. Future programming is required to control the backlight. The signal from the Dpad will be processed by a DAC with a R-2R structure, to convert the 6 inputs from the Dpad to a binary coded 8bit voltage. Note that only UIcontrol analog signal is used, the second output is left connected. Now. Heating element The heating element chosen is one that is powered by AC 240V input, at the connector, HE1. KBP206G is the rectifier to convert AD into DC voltage. The 4N35SM photocoupler will convert the rectified wave and generate an on and off 5V signal to the microcontroller to locate the zero-crossing point of the input wave. This will allow the microcontroller to align the output from this zero-crossing moment if necessary. MOC3020 is the photocoupler, between DC to AC using a triac. This component allows the microcontroller to sink the current at the cathode (the negative, pin 2) of the MOC3020 diode. Allowing the microcontroller to control the pulse powering the heating element by driving the BT1365 triac. R6, R9 and C2, are there to protect the MOC3020 from load, and R10 and C3 form the snubber to protect the triac. Additional cutout on PCB to increase the effective isolation between the 240V on each contact of the rectifier. The AC circuit is located at a different part of the PCB, and the pinout for controlling the heating element is done by a 4ways connector as shown above. A jumper cable will be required to connect this connector, MUC_HEAT_OUT1, with the one input 4ways connector, MCU_heating_IN1, connection the MOC3020 and 4N35 IC. Sensors There are three main sensors: temperature, tank high level, and flow out sensor Temperature sensor is currently unuse, it is supposed to serve as the feedback to control the heating element. It is using a one-wire bus to transmit its digital data. The sensor used here is DS18B20. The tank high level sensor is a 4 pins socket connecting to a capacitance sensor mounted to the tank and will trigger a on signal when the water level is raised. The flow out sensor is a 4 pins socket connecting to two capacitance sensors clipped to the outlet tubbing from the tank to the solenoid valve, and will trigger a signal when they sense the tube has fluid inside. Buzzer A buzzer is integrated to the board, this allows the program to give out audio clues to the user/operator when things happen. See software documentation to see the list of audio clues. Communication Ports There are two types of communication port accessible from the boards via three ports: There are two I2C ports, 4 ways, with one of the port has an extra set of pulled up resistor for a new additional device There is a 16way IDC SPI communication port. This is currently used for the SD card module. The hardware is suitable for any SPI device. The parallel pin socket allow another device to be piggy-back to the same port. Microcontroller pinout A pinout diagram of the microcontroller to all the other components on the board. Some basic components such as transistor and resistor are added depending on the signal the pin is interfacing with. This would change depending on the programs being uploaded to the microcontroller. All the extra pins are tentatively grouped to an IDC header for future development and expansion.","title":"v0.9"},{"location":"circuit/v0_9/#v09","text":"The original working prototype for CP800 The function of the board is broken down into the following sections: 1) The power transfer to each of the components below 2) The pumps 3) The motor 4) The fluid sensors feedback 5) The solenoid valves for flow control 6) The user interface 7) The heating element","title":"V0.9"},{"location":"circuit/v0_9/#power-circuit","text":"Both 12V and 5V comes from the external switch converter and are reverse polarity protected with low on resistance p-channel MOSFET and Zener diode. The Arduino is powered via the 5V pin bypassing the LDO that required a higher voltage to power. And all 12V and 5V components will be supplied by these two voltage sources. There are four power connectors, one is the input from the 12V PSU, one is the 12V output after the reverse polarity protection, one is 5V voltage input from the buck converter, and the last one is an extra header for a 5V reference.","title":"Power circuit"},{"location":"circuit/v0_9/#pumps-control","text":"There are three output ports for pumps. They are 2pin output. Each pump is driven by a power MOSFET to switch them on and off with a low side BJT transistor as the gate driver. A high output in the microcontroller will allow gate to discharge thru the BJT quickly, and achieve a faster turn off of the pumps. Meanwhile, a low output on the microcontroller will turn the BJT off, and the MOSFET gate is charged thru the low resistance pull up resistor, to achieve a regulated turn on time. The pull up resistor in the microcontroller signal pin is implemented in the case where these pins are not programmed. The pull up resistors will ensure the pump is off when these pins are not programmed. Fuses are installed to prevent over current, and a flyback Schottky diode is used to limit voltage surge by the induction load from the pumps.","title":"Pumps control"},{"location":"circuit/v0_9/#motor-control","text":"The motor control is very similar to the pump control as they are both inductions loading presumably. The motor we are using has 5 pins control: PWR, DIR, PWN, FB, GND. We don't use the current feedback wire, so it is left out of the port output intentionally. The motor is then connected to the 4 pins JST XH output on the board. In order to turn on the motor, we need the PWE pin to be 12V, and the GND pin to be 0V. There is a fuse of the appropriate current to limit over current, and there is a flyback Schottky diode to limit voltage surge. Both DIR and GND pins are controlled by power MOSFETs to switch between 12V and 0V. A pulled up resistor of 12V is in place for the DIR pin, so there is a default DIR of rotation for the motor, if the pin is left hanging. The low side BJT allows a quick discharge of gate, and the low resistance pull up allows a fixed time fast charging up to the gate. The pulled up in the microcontroller pins are to make sure the DIR and 0V pin are forced to 12V and keep the motor off, if these pins are not programmed by the microcontroller.","title":"Motor Control"},{"location":"circuit/v0_9/#solenoid-valves-control","text":"Both add and remove valves are controlled in the same way. Since solenoid is a highly inductive load, we have to apply a voltage of 12V across each pair of contact on the solenoid block. Similar to motor and pumps, a fuse to protect from over current and flyback Schottky diode for voltage surge. Each solenoid is switched on and off by a MOSFET with a low side BJT driver for fast drain in gate and a pulled-up resistor in case of unprogrammed microcontroller pins to the demultiplexer, CD4051.","title":"Solenoid valves control"},{"location":"circuit/v0_9/#user-interface","text":"There are two connectors between the motherboard and the Dpad board. These control the user interface. The 10ways IDC connector is the connection with each button and LED on the Dpad. The 10ways JST XH header is the signal going to the LCD screen. The screen is turned on and off by MOSFET, the program is currently locked to stay on. Future programming is required to control the backlight. The signal from the Dpad will be processed by a DAC with a R-2R structure, to convert the 6 inputs from the Dpad to a binary coded 8bit voltage. Note that only UIcontrol analog signal is used, the second output is left connected. Now.","title":"User interface"},{"location":"circuit/v0_9/#heating-element","text":"The heating element chosen is one that is powered by AC 240V input, at the connector, HE1. KBP206G is the rectifier to convert AD into DC voltage. The 4N35SM photocoupler will convert the rectified wave and generate an on and off 5V signal to the microcontroller to locate the zero-crossing point of the input wave. This will allow the microcontroller to align the output from this zero-crossing moment if necessary. MOC3020 is the photocoupler, between DC to AC using a triac. This component allows the microcontroller to sink the current at the cathode (the negative, pin 2) of the MOC3020 diode. Allowing the microcontroller to control the pulse powering the heating element by driving the BT1365 triac. R6, R9 and C2, are there to protect the MOC3020 from load, and R10 and C3 form the snubber to protect the triac. Additional cutout on PCB to increase the effective isolation between the 240V on each contact of the rectifier. The AC circuit is located at a different part of the PCB, and the pinout for controlling the heating element is done by a 4ways connector as shown above. A jumper cable will be required to connect this connector, MUC_HEAT_OUT1, with the one input 4ways connector, MCU_heating_IN1, connection the MOC3020 and 4N35 IC.","title":"Heating element"},{"location":"circuit/v0_9/#sensors","text":"There are three main sensors: temperature, tank high level, and flow out sensor Temperature sensor is currently unuse, it is supposed to serve as the feedback to control the heating element. It is using a one-wire bus to transmit its digital data. The sensor used here is DS18B20. The tank high level sensor is a 4 pins socket connecting to a capacitance sensor mounted to the tank and will trigger a on signal when the water level is raised. The flow out sensor is a 4 pins socket connecting to two capacitance sensors clipped to the outlet tubbing from the tank to the solenoid valve, and will trigger a signal when they sense the tube has fluid inside.","title":"Sensors"},{"location":"circuit/v0_9/#buzzer","text":"A buzzer is integrated to the board, this allows the program to give out audio clues to the user/operator when things happen. See software documentation to see the list of audio clues.","title":"Buzzer"},{"location":"circuit/v0_9/#communication-ports","text":"There are two types of communication port accessible from the boards via three ports: There are two I2C ports, 4 ways, with one of the port has an extra set of pulled up resistor for a new additional device There is a 16way IDC SPI communication port. This is currently used for the SD card module. The hardware is suitable for any SPI device. The parallel pin socket allow another device to be piggy-back to the same port.","title":"Communication Ports"},{"location":"circuit/v0_9/#microcontroller-pinout","text":"A pinout diagram of the microcontroller to all the other components on the board. Some basic components such as transistor and resistor are added depending on the signal the pin is interfacing with. This would change depending on the programs being uploaded to the microcontroller. All the extra pins are tentatively grouped to an IDC header for future development and expansion.","title":"Microcontroller pinout"},{"location":"circuit/v0_92/","text":"V0.92 (in machine after ) Changes: 1) Removed pull up resistor for direction pin of the motor 2) Number of extra pins reduced 3) One additional IDC socket for joystick shield 4) Pin out header socket for USB host shield, required one additional stacking pins 5) Removed the extra ICSP pins, it is now used by the USB host shield 6) Use one 5V LDO (AMS1117) onboard required low voltage input of at least 6.5V 7) Arduino mage gets power from Vin around 6.5V and signals powered from onboard 5V LDO (AMS1117) 8) One PISO shift registers for Dpad buttons input are available instead of the R-2R ladder analog output to buttons 9) Red onboard LED for reverse voltage input for both 12V and low voltage terminals 10) Green onboard LED for forward voltage input for both 12V and low voltage terminals 11) Mounting holes increase from M3 to M4, holes position remains the same 12) Size of board increase in the X-axis Power circuit Both 12V and low voltage (6.5V) from the external switch converter are reverse polarity protected with low on resistance p-channel MOSFET and Zener diode. When reverse polarity occurred, the pMOSFET will shut down the main circuit from the high voltage side, but the red SMD LED will turn on as an indication for the user that they had reversed the input leads When the correct polarity is inserted, the pMOSFET will shunt the high voltage side leads, and activate the green SMD LED. One additional 5V regulator is implemented to share the loads required by the 5V sources. This is the same chip as the 5V LDO on the Arduino mega pro mini In the schematics diagram, 5V is the one powered by the Arduino, while all 5V_EX connection is powered by this additional chip. There are four power connectors, one is the input from the 12V PSU, one is the 12V output after the reverse polarity protection, one is low voltage input from the buck converter, and the last one is an extra header for a 5V reference. Pumps control Remain unchanged Motor control The only changes made are the direction pin of the motor. Now the pin is left floating/disconnected if it is not shorted to GND for backward direction The change is made because the motor we used is not a raw motor, it is a DIR and PWM controlled motor. Therefore, there is a controller board inside the motor assembly. Depending on the quality of the motor, if there is a current path inside the motor assembly, the additional pull up resistor outside the assembly will affect the voltage level on that pin. Also, according to the product datasheet, the DIR pin could be left disconnected for forward direction, thus proving there is an internal pull up inside the motor assembly. The rest is the same as the previous version. Solenoid valves control Same as previously User interface The Dpad function works as previously In v0.92, there are two additional components added for the user interface Firstly, the 12ways IDC connector allows the microcontroller to interface with Arduino joystick shield. Since we don't plan to use key E and F, they are left disconnected with the microcontroller here. This is a optional addon, the Dpad functions as usual without the connection with joystick shield, and the joystick shield will work simultaneously with the Dpad. The addition of a parallel in and series out shift register allows pure digital signal to be transmitted to the microcontroller for all the Dpad buttons. This required additional programming that allowed the signal to be read via the UI_Serin input for all 8 buttons. Heating element Same as previously But, DO note that MOC3020, and 4Nm5 might need to be changed to other equivalent components due to availability. Arduino USB Host shield dock This layout allows the Arduino USB Host shield to be connected simply by docking it over these docking headers. Most of the bypassing digital and analog pins from the shield are unuse. They are included for structural reasons. The USB host shield converts the USB signal into SPI interface to the microcontroller. This has been tested and used with a Bluetooth USB dongle, and communicates with a PS5 controller to act as the user interface to navigate the menu. Sensors Same as previously Buzzer Same as previously Communication Ports Same as previously Microcontroller pinout The left side of the picture is the header arrangement on the board for docking the arduino board. The right is the labeled pinout of the Arduino. A additional fuse is added to the Vin to the Arduino board, since in v0.9, power is feed via the 5Vport of the Arduino bypassing the 5V LDO onboard. Extra pin unused pin is group to an extra IDC header for future expansion. This has been significantly reduced due to the module expansion and component compatibility from v0.9 to v0.92. The firmware is made backward compatible, so the program being uploaded to this board that processes all the added component to this iteration of PCB can also be uploaded to v0.9 without causing a bug. However, all new features in v0.92 will not reflect on v0.9 unless the corresponding extra pins are wired externally.","title":"v0.92"},{"location":"circuit/v0_92/#v092-in-machine-after","text":"Changes: 1) Removed pull up resistor for direction pin of the motor 2) Number of extra pins reduced 3) One additional IDC socket for joystick shield 4) Pin out header socket for USB host shield, required one additional stacking pins 5) Removed the extra ICSP pins, it is now used by the USB host shield 6) Use one 5V LDO (AMS1117) onboard required low voltage input of at least 6.5V 7) Arduino mage gets power from Vin around 6.5V and signals powered from onboard 5V LDO (AMS1117) 8) One PISO shift registers for Dpad buttons input are available instead of the R-2R ladder analog output to buttons 9) Red onboard LED for reverse voltage input for both 12V and low voltage terminals 10) Green onboard LED for forward voltage input for both 12V and low voltage terminals 11) Mounting holes increase from M3 to M4, holes position remains the same 12) Size of board increase in the X-axis","title":"V0.92 (in machine after )"},{"location":"circuit/v0_92/#power-circuit","text":"Both 12V and low voltage (6.5V) from the external switch converter are reverse polarity protected with low on resistance p-channel MOSFET and Zener diode. When reverse polarity occurred, the pMOSFET will shut down the main circuit from the high voltage side, but the red SMD LED will turn on as an indication for the user that they had reversed the input leads When the correct polarity is inserted, the pMOSFET will shunt the high voltage side leads, and activate the green SMD LED. One additional 5V regulator is implemented to share the loads required by the 5V sources. This is the same chip as the 5V LDO on the Arduino mega pro mini In the schematics diagram, 5V is the one powered by the Arduino, while all 5V_EX connection is powered by this additional chip. There are four power connectors, one is the input from the 12V PSU, one is the 12V output after the reverse polarity protection, one is low voltage input from the buck converter, and the last one is an extra header for a 5V reference.","title":"Power circuit"},{"location":"circuit/v0_92/#pumps-control","text":"Remain unchanged","title":"Pumps control"},{"location":"circuit/v0_92/#motor-control","text":"The only changes made are the direction pin of the motor. Now the pin is left floating/disconnected if it is not shorted to GND for backward direction The change is made because the motor we used is not a raw motor, it is a DIR and PWM controlled motor. Therefore, there is a controller board inside the motor assembly. Depending on the quality of the motor, if there is a current path inside the motor assembly, the additional pull up resistor outside the assembly will affect the voltage level on that pin. Also, according to the product datasheet, the DIR pin could be left disconnected for forward direction, thus proving there is an internal pull up inside the motor assembly. The rest is the same as the previous version.","title":"Motor control"},{"location":"circuit/v0_92/#solenoid-valves-control","text":"Same as previously","title":"Solenoid valves control"},{"location":"circuit/v0_92/#user-interface","text":"The Dpad function works as previously In v0.92, there are two additional components added for the user interface Firstly, the 12ways IDC connector allows the microcontroller to interface with Arduino joystick shield. Since we don't plan to use key E and F, they are left disconnected with the microcontroller here. This is a optional addon, the Dpad functions as usual without the connection with joystick shield, and the joystick shield will work simultaneously with the Dpad. The addition of a parallel in and series out shift register allows pure digital signal to be transmitted to the microcontroller for all the Dpad buttons. This required additional programming that allowed the signal to be read via the UI_Serin input for all 8 buttons.","title":"User interface"},{"location":"circuit/v0_92/#heating-element","text":"Same as previously But, DO note that MOC3020, and 4Nm5 might need to be changed to other equivalent components due to availability.","title":"Heating element"},{"location":"circuit/v0_92/#arduino-usb-host-shield-dock","text":"This layout allows the Arduino USB Host shield to be connected simply by docking it over these docking headers. Most of the bypassing digital and analog pins from the shield are unuse. They are included for structural reasons. The USB host shield converts the USB signal into SPI interface to the microcontroller. This has been tested and used with a Bluetooth USB dongle, and communicates with a PS5 controller to act as the user interface to navigate the menu.","title":"Arduino USB Host shield dock"},{"location":"circuit/v0_92/#sensors","text":"Same as previously","title":"Sensors"},{"location":"circuit/v0_92/#buzzer","text":"Same as previously","title":"Buzzer"},{"location":"circuit/v0_92/#communication-ports","text":"Same as previously","title":"Communication Ports"},{"location":"circuit/v0_92/#microcontroller-pinout","text":"The left side of the picture is the header arrangement on the board for docking the arduino board. The right is the labeled pinout of the Arduino. A additional fuse is added to the Vin to the Arduino board, since in v0.9, power is feed via the 5Vport of the Arduino bypassing the 5V LDO onboard. Extra pin unused pin is group to an extra IDC header for future expansion. This has been significantly reduced due to the module expansion and component compatibility from v0.9 to v0.92. The firmware is made backward compatible, so the program being uploaded to this board that processes all the added component to this iteration of PCB can also be uploaded to v0.9 without causing a bug. However, all new features in v0.92 will not reflect on v0.9 unless the corresponding extra pins are wired externally.","title":"Microcontroller pinout"}]}